- å†…å®¹: 'Animating Shapes'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Learn how to use shapes and simple animations in SwiftUI.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'First up, youâ€™ll learn to use the SwiftUI Shape protocol to create and modify shape views.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Youâ€™ll learn the basics of animating views and how to create animations â€“ some easy, some more complex!'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Heart Pulse'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Discover how to make a heart pulse in this basic animation.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 1'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'In this walkthrough, you will learn how to create a custom heart shape as well as how to make it pulse. From there, youâ€™ll learn how to scale the pulsing heart up or down.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 2'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'To create a heart shape, define a structure that adopts the Shape protocol by implementing the required path(in:) method.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 3'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'path.move starts the path at the point of the heart.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 4'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'path.addCurve creates a curved line from where your point is to a specified end point. This is what draws the curved sides of the heart shape.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 5'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'path.addArc adds the arcs at the top of the heart shape. By specifying the start and end angles, the path knows where to draw the arc. The arc is drawn off of specific points in the unit circle that you specify for the start and end angles.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 6'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'To make the heart pulse, youâ€™ll tap the play button. When the heart pulses, it scales up and then back down, repeating the animation indefinitely. Your heartPulse state property determines the scale of the heart in this animation.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 7'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'When you tap play, the heartPulse value increases. Setting autoreverses to true allows the animation to first play forward, as the heart scales up, and then backward as it scales back down again.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 8'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'By changing the value of heartPulse inside of a withAnimation closure, you animate any changes to its value with the animation you pass in, resulting in the pulsing effect. ğŸ’—'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Spinning Animation'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Discover how to create a spinning effect.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Next, youâ€™ll learn to create a spinning animation when you tap a button. Time to get dizzy!'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'There is no preset animation that actually causes a shape to spin, but you can create the illusion of spinning by changing the width of the shape. To do this, youâ€™ll use a width state property.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'When you tap the button, the ellipse animates to change its width from 200 to 0. Notice that the Animation used is .easeInOut.repeatForever(autoreverses: true).speed(2). This chains together three animations to create a specific effect. Try to predict how each part of the animation affects the overall effect.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Hereâ€™s the sequence: .easeInOut first creates an animation that eases in and eases out. Then .repeatForever(autoreverses: true) takes the .easeInOut animation and puts it in a loop that runs forever. Because autoreverses is true, the animation first runs forward, then in reverse before starting over. And finally, .speed(2) determines how quickly the animation runs. With an argument of 2, it runs at 200 percent of its default speed.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'This animation results in a spinning effect as the circleâ€™s width changes first from 200 to 0, and then from 0 to 200, repeating the entire animation on a recurring loop.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Exploding Animation'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Learn how to create an explosion effect.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'To create an exploding animation, youâ€™ll replace a rectangle with many small rectangular pieces that animate outward.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'The isExploded state property tracks whether the exploding animation is currently running. Youâ€™ll use this value to start all of the animations when you tap the button.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'In the large Rectangle view, the opacity animates from 1 to 0 when isExploded is set to true; this makes the large rectangle disappear.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'When the large rectangle disappears, you want many small rectangles to explode outward. To create this effect, youâ€™ll first generate a large number of smaller rectangles using a ForEach. These rectangles are initially hidden behind the large rectangle in a ZStack. When the large rectangle disappears, youâ€™ll see the smaller rectangles.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Experiment'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Try changing the number of small rectangles to see how that affects the animation.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'For each of these small rectangles, youâ€™ll use a conditional modifier to animate their offsets to random positions in the view. This makes it look like theyâ€™re little shards of the larger rectangle that propel out in different directions.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Add a twist! Try changing the speed of the ease-in -out animation for the small rectangles and see what happens.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'As those little rectangles explode out, youâ€™ll fade their opacity from 1 to 0 so they eventually disappear. And thatâ€™s your explosion animation. Now, you may be thinking, â€œThis isnâ€™t a real explosion, itâ€™s an illusion.â€, and youâ€™re absolutely right. All animations are illusions, and youâ€™re the magician who creates them. ğŸª„'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Use scaling and animation delays to create a wave effect.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Now that youâ€™ve dabbled with some basic animations, take a look at how you can combine them to create a more advanced interactive effect. Youâ€™ll learn how to animate a grid of circles to form a fabulous wave effect when you tap them. In the preview, try tapping on different circles in the grid. What do you notice?'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Youâ€™ll need a few state properties to keep track of how the circles change when you tap them. The gridColumns property defines the columns for the grid, and colors provides the color options for the rainbow effect.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Try changing the number of columns, by changing the value for count in gridColumns. What happens if you change the colors in the colors array?'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'The numCircles constant defines the number of circles in your grid. Your LazyVGrid uses gridColumns and numCircles to generate the initial grid of circles.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Try changing the value of numCircles and see how your grid changes.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'The springAnimation constant defines the animation to use later in the animation modifier.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Try changing some of these values and tap the grid to see how they affect the animation.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Your springAnimation is used to animate changes to the scale of the circles in the grid. However, to create a rolling wave effect you want to animate the circles in your grids at different times. Add delay(_:) to springAnimation to specify the duration of the animation delay for each individual circle. To calculate the delay, divide the circleâ€™s index by the number of columns, taking the truncating remainder as a value between 1 and 10 (the number of columns). This creates a per-column animation effect.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'The .animation modifier determines how the circle animates, but the value for scaleFactor and any changes made to scaleFactor are what causes the increase in scale.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'The tapGesture modifier allows you to change the scaleFactor by tapping a circle in the grid. When you tap a circle, the value of scaleFactor is set based on that circleâ€™s index. The further the circleâ€™s position is in the grid, the larger the scaleFactor will be.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Because the index of circles starts at 0, you need to set the scaleFactor using index+1 so you never have to set the scaleFactor to an undefined number.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 9'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'There you have itâ€¦a beautiful rolling rainbow!'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Try tinkering with this animation until itâ€™s exactly as you like it. Good luck!'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Use a drag gesture to move a grid of dots.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Dragginâ€™ Drop Dots is very similar to Rollinâ€™ Rainbow, but with some differences. Instead of changing the scale of the circles when you tap them, the circleâ€™s offset changes based on a drag gesture applied to the entire grid. Time to dive into the code.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'This is a much larger grid than Rollinâ€™ Rainbow â€“ there are a lot more circles and columns. See what happens when you change the number of dots in the grid. Do you need more circles in this animation?'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Add a drag gesture instead of a tap gesture so the grid moves when you drag it. You can use the translation value in the drag gesture closure to set the offset of each circle, resulting in the entire grid moving to the new drag.translation value.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'When the offset changes, youâ€™ll animate the circles to their new positions. Instead of moving all of the dots at the same time, you can use delay on the animation so that each circle moves individually. If you set the delay based on each circleâ€™s index, the circles will have a slightly different delay. This results in the entire grid animating one circle after the other. Because this animation would otherwise be very slow, you can divide the value for delay by the animationSpeed value to speed it up.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Try changing the animationSpeed to something very low, like 20. How does the animation change?'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Dancing Dots'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Make the circles boogie!'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Animate more complex model data in cool and interesting ways using observable objects.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'What if the changes you want to animate arenâ€™t coming from user actions? SwiftUI has a way of animating published values in observable objects. Create an observable object BigDot that publishes an offset, color, scale, and an array of small dot observable objects. Youâ€™ll use this object to model the view animations you want in your view.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Add a SmallDot observable object that publishes a color and an offset.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'When you create a bigDot, you also need to create an array of small dots that are linked to the big dot.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Now, a grid of big dots needs to populate the grid with five small dots for every big dot. Because there are so many dots, youâ€™ll use a DotTracker class when publishing an array of BigDots. This is the published value youâ€™ll track to create your animations. What happens to the animation if you increase or decrease the number of smallDots in the array?'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Your bigDots array has 100 BigDot instances that appear in the grid view.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'You may notice that the BigDot class and DotTracker both include a randomizePositions() function that do almost the same thing. The function in BigDot creates random positions for each SmallDot in its smallDot array, while the function in DotTracker creates random positions for each BigDot. Together, these functions create the changes in the offset, color, and scale values reflected by animations in your grid view.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Try changing the value of the scale in the randomizePositions() function. What happens to the animation when you lower the scale value?'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Add a resetPositions() function, so the dots reset to their original positions when you tap the reset button. This is very similar to the randomizePositions() function used to place circles in random locations around the view.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'The randomizePositions() function calls bigDot.randomizePositions(). This puts every SmallDot in the smallDot array defined in the BigDot class into random positions.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'The DancingDotsView needs to define an instance of the DotTracker as a @StateObject so SwiftUI redraws its contents whenever any of the viewâ€™s dots change color or position.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 10'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Add in this ForEach loop to place each BigDot tracked by the tracker into the grid.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 11'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'For each BigDot, you can create a circle view with its offset, color, and scale.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 12'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Because every BigDot has five SmallDots, you can do the same thing for the small dots.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 13'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'When you tap the play button, the circles animate and the randomizePositions() function is called. This causes the circlesâ€™ offsets to change, creating a dancing effect for the dots.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 14'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Add this isAnimating state property, which calls the resetPositions() method and resets the circleâ€™s positions when you tap Reset.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 15'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Because everything is animating, adding drawingGroup() helps to make the animation render smoothly.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Step 16'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Now you know how to create more complex animations with shapes. Time to take what youâ€™ve learned in this guide and use it to make some cool Swift apps!'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Previewing the Camera Output'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Preview the output from the camera.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Rollin Rainbow'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Draggin Drop It'
  æç¤º: ''
  ç¿»è¯‘: ''
