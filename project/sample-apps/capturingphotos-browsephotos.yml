- å†…å®¹: Note
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Fetching the Photo Assets
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: You use a lazy vertical grid (LazyVGrid) to display your photos as items in
    a grid layout. Because the layout uses a vertical grid, you only need to decide
    how many columns you want and the spacing between each item. After the grid has
    the number of columns, it expands vertically to add enough rows for displaying
    all of your photos.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Your result closure looks for an image in the result. If it finds one, it updates
    your image property.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 5
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Enjoy taking photos? Most of us do, and itâ€™s easy to end up with hundreds or
    thousands of photos in your library. ğŸ
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Using the Photo Collection
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: When you open the gallery, youâ€™ll no longer see the viewfinder, so thereâ€™s no
    need to keep updating it. Instead, youâ€™d rather concentrate the deviceâ€™s performance
    on displaying your photos. To control when the cameraâ€™s preview stream is active,
    use the navigation linkâ€™s onAppear(perform:) modifier to pause it when the gallery
    appears, and onDisappear(perform:) to resume it again when you navigate back to
    the camera.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Each item in your photo collection is known as a photo asset. Find out how to
    fetch those assets.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: A view can use its task(priority:_:) modifier to run some code asynchronously
    whenever the view loads.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 6
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Tip
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: The photoItemView(asset:) method creates a view that displays a small image
    thumbnail for a photo asset. Youâ€™ll use this view as the label for the navigation
    link, displaying each link as a thumbnail-sized image of the photo.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: In your camera view, use a navigation link to take you to your photo gallery.
    A navigation link is just like a button â€” you can even give it a label and an
    icon. You place this button to the left of the shutter button.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Why lazy? Well, if the grid is larger than its containing view, the view only
    displays the items that are currently visible. This â€œlazinessâ€ actually enhances
    the performance of your app, especially as you scroll through the grid of photos.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: You could use a fixed number of columns in your grid, but a more responsive
    approach is to display as many columns as you can, depending on the width of the
    view. This creates a much better experience as people resize your app. To create
    a grid that adapts to the width of your view, define an adaptive GridItem and
    specify the size and spacing you want it to maintain.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Your view has an image state property ready to hold the image after loading
    it. Itâ€™s an optional type â€” Image? â€” because you want it to start off without
    any value.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Displaying a Photo
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Your result closure receives one or more calls from the cache. If the cache
    already contains the image you requested, it immediately calls your closure with
    the image in its result. If the cache doesnâ€™t have the requested image, then it
    loads the image from the photo asset and caches it. While loading the image, the
    cache may first call your closure with a low-resolution image, before finally
    delivering the high-resolution image in the result.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: You use a PhotoCollectionView to display your photos in a scrolling grid, with
    the most recent photos at the top.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'Your data modelâ€™s photoCollection has a photoAssets property that enables use
    of the photo assets collection just like you would an array. You can fetch a photo
    asset using its index: photoAssets[4], or use photoAssets.count to get the number
    of photos in the collection.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Browse the photos in your photo library.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 3
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 8
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: When you tap or click a navigation link, SwiftUI takes you to another view â€”
    in this case, the photo collection view â€” that you use to display your photo gallery.
    If you use navigation links within a NavigationStack, SwiftUI manages the presentation
    of your views so you can easily navigate between them.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 4
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Learn about the photo collection in your data model and how it provides the
    photos for your gallery.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Learn how the photo view loads and displays your photo.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Youâ€™ll notice that photoAssets is a published property of PhotoCollection, which
    is an observable object. This means that you can respond to changes in the photo
    assets, such as when photos are added or deleted.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 9
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: This is where you add code to request a high-resolution image from the cache
    for the photo asset, specifying the size you want. You also provide the cache
    with a closure that contains code it can call when it has a result.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Find out how to navigate to the photo gallery and connect it to your photo library.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Recognizing Gestures with Machine Learning
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Create a NavigationLink for each grid item that, when tapped or clicked, displays
    the individual photo at full size using the destination PhotoView initialized
    with the photo asset.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 1
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: You also initialize the view with a cache property that holds a reference to
    your image cache. You can request an image of a specified size from the image
    cache. After loading the image from the photo asset, the cache delivers it back
    to you. The image cache also keeps recently-requested images in memory, so it
    doesnâ€™t have to reload them if you request them again.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Inside your grid, use ForEach to iterate over the photo assets in your collection
    and generate a view for each asset â€” these views populate your grid. Because your
    grid is lazy, as you scroll, ForEach only operates on the visible photo assets.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Browsing Your Photos
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Navigating to the Photo Gallery
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: When it comes to displaying a photo on its own, youâ€™ll use PhotoView. In your
    photo view, you display a high-resolution image that you request from the photo.
    You also have an overlay with buttons for favoriting or deleting the photo.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 7
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: By passing your modelâ€™s photoCollection to the PhotoCollectionView when you
    initialize it, you provide the collection of photos that you want to display in
    your gallery.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 10
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Discover how to display your photos in a scrolling grid.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: You can also iterate over the assets in photoAssets using a loop. Youâ€™ll find
    this incredibly useful for building your gallery.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: When you create your PhotoCollectionView, the photoCollection property initializes
    with a reference to your modelâ€™s photoCollection. It provides all of the data
    you need to build your photo gallery. By making photoCollection an observed object,
    SwiftUI updates your photo collection view in response to changes in the collectionâ€™s
    published values.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: However, if image doesnâ€™t have a value, you use a ProgressView to display a
    spinner as a placeholder. Look very carefully, and you might just see this spinner
    when your view first loads, before the cache has a chance to load an image from
    the photo asset.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Imagine having hundreds â€” or thousands â€” of photos. Even with adaptive layout,
    your grid can get very tall â€” way taller than the space you have to display it!
    Make your grid scrollable by placing it inside a ScrollView. This makes it so
    your grid can have as many rows as it needs, and youâ€™ll be able to scroll up and
    down through your photos.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Your photo view has a photoAsset property for the photo it displays. You pass
    this in when you initialize the PhotoView.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Building the Photo Gallery
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 2
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Follow your photos as theyâ€™re retrieved from your photo library and displayed
    in a scrolling gallery you can browse.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Your data model has a photoCollection property that can represent any collection
    of items in your photo library. This could be your entire photo library, or just
    one album, or even the results from a search. You can include all of your photos
    in your library by initializing photoCollection with a Smart Album .smartAlbumUserLibrary.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Explore how to transform hand pose images from the camera into readable data
    your machine learning model can use to predict gestures.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Because youâ€™ve made image a state property, SwiftUI updates your view when its
    value changes. If image contains a value, you unwrap the image and display it
    in your view.
  æç¤º: ''
  ç¿»è¯‘: ''
