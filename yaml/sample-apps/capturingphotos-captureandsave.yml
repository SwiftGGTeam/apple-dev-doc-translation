- å†…å®¹: Step 5
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Processing and Saving a Photo
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: The savePhoto(imageData:) method creates a task and passes on the real work
    of saving the photo data to the photoCollection object by calling its addImage(_:)
    method. And thatâ€™s fine! The data modelâ€™s job is to coordinate data flow between
    the appâ€™s data objects.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: When you take a photo, you want to capture an image with the highest possible
    resolution. This contrasts with the preview images, which tend to have a lower
    resolution to facilitate rapidly updating previews in the viewfinder. Your camera
    has a special photo output that its takePhoto() method uses to capture high-resolution
    images of what you see in the viewfinder.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Now that youâ€™ve got the captured photo, you add it into the cameraâ€™s photo stream.
    Itâ€™s then available to any object in your app waiting for a photo, like the data
    model.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: The for-await loop now waits for a photoData element to arrive in your unpacked
    stream before processing it.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 6
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Tip
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Responding to the Shutter Button
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Youâ€™ll recall that, as an asynchronous stream, photoStream is very much like
    a Sequence. You can use its compactMap(_:) method to call unpackPhoto(_:) for
    each photo ($0) in the stream. This transforms the stream of AVCapturePhoto instances
    into a much more useful stream of PhotoData instances.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Call your modelâ€™s savePhoto(imageData:) method to save the image data from photoData
    as a new photo in your photo library.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Browse the photos in your photo library.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 3
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 8
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 4
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: To unpack the photoStream, youâ€™ll use the unpackPhoto(_:) function, which takes
    a captured photo and returns a PhotoData instance that contains a low-resolution
    image thumbnail as an Image, the size of the image thumbnail, a high-resolution
    image as Data, and the size of the high-resolution image.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: The button springs into action, grabs the modelâ€™s camera object, then calls
    its takePhoto() method. Keep going to find out how it takes a photo!
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: When you take a photo, the camera captures image data from its sensor. Learn
    how to initiate this, and handle the resulting captured photo.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Capturing a Photo
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: When you tap or click the shutter button in your camera view, things start happening!
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'You might wonder why capturePhoto doesnâ€™t just return the photo. Thatâ€™s because
    capturing a photo takes time: the camera may need to focus, or wait for the flash,
    and then thereâ€™s the exposure time. The capturePhoto method is asynchronous, with
    the captured photo typically arriving a short time after you tap or click the
    shutter button.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 1
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Browsing Your Photos
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: You use the thumbnail image in photoData to update your modelâ€™s thumbnailImage
    property.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Your data model is patiently awaiting newly-captured photos. Just as for preview
    images, it has a dedicated task for handling the captured photo stream from the
    camera, using its handleCameraPhotos method.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Take photos with the camera, add them to your photo library, and display them
    in your app.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Smile! Click! A lot happens in quick succession when you take a photo. ğŸ“¸
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Follow the action after you tap or click the shutter button, to investigate
    what happens from that moment to when the photo shows up in your photo library.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: 'After the photo capture has completed, you receive a callback to another method
    in your camera object: photoOutput(_:didFinishProcessingPhoto:error:). Its first
    argument receives the captured photo as an instance of AVCapturePhoto.'
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: You start the real work of taking the photo by requesting the photo output to
    capture a photo. If all goes well, this is when you hear a reassuring shutter
    sound to let you â€” and anyone nearby â€” know that youâ€™ve just taken a photo.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Learn how to handle the shutter button action, and request the camera to take
    a photo.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Capturing and Saving a Photo
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 2
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: You can learn more about Tasks in the Swift standard library.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Discover how to unpack a captured photo and save it to your photo library.
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Step 7
  æç¤º: ''
  ç¿»è¯‘: ''
- å†…å®¹: Each AVCapturePhoto element in the cameraâ€™s photoStream may contain several
    images at different resolutions, as well as other metadata about the image, such
    as its size and the date and time the image was captured. You have to unpack it
    to get the images and metadata that you want. The first thing you do in handleCameraPhotos
    is to convert photoStream into a more useful unpackedPhotoStream, in which each
    element is an instance of the PhotoData structure that contains the data you want.
  æç¤º: ''
  ç¿»è¯‘: ''
